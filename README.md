# Крестики-Нолики

### Игра состоит нз следующих компонентов:
* **platforms** - *пакет* содержит поддерживаемые платформы (Терминал, SWING)
* **users** - *пакет* содержит возможные типы игроков (боты, реальный пользователь)
* **AI** - *класс* с конфигурацией нейронной сети
* **Board** - (В корне проекта) *интерфейс* описывающий игровую доску 3х3
* **Game** - (В корне проекта) *класс* реализующий механику игры
* **Main** - (В корне проекта) *класс* точка входа в программу. Настраивает и запускает игру.


#### Platform
> интерфейс


Название метода                     | Описание
------------------------------------|-----------------------------------------------------------------------------------------------------------
**`void inviteUserToTurn(SIGN t)`** | Вывести на экран, специфичным для платформы способом, приглашение для пользователя, чей ход, сделать ход.
**`void draw(SIGN[] board)`**       | Нарисовать состояние доски переданной в параметре **board**.
**`int getUserTurn()`**             | Получить от платформы **индекс** хода сделанный пользователем.
**`void showResult(int xWin, int oWin, int standoff)`**|  Вывести на экран счет игры.
**`void winX()`**                   | Оповещение платформы о том, что выиграл пользователь **X**.
**`void winO()`**                   | Оповещение платформы о том, что выиграл пользователь **O**.
**`void standOff()`**               | Оповещение платформы о том, что произошла ничья.

#### Реализации интерфейса Platform:
* **TerminalPlatform** - реализует взаимодействие с терминалом. Ввод/Вывод в консоль \
  `Platform platform = new TerminalPlatform();`
* **UIPlatform** - реализует UI на SWING и реализовывает взаимодейсвие с графическим интерфейсом. \
  `Platform platform = new UIPlatform();`
  
#### User
> интерфейс


Название метода                     | Описание
------------------------------------|-----------------------------------------------------------------------------------------------------------
**`int makeTurn(SIGN[] board)`**    | Сделать ход. Аргумент **board** содержит текущее состояние доски игры
**`void win()`**                    | Оповещение о том, что пользователь выиграл.
**`void lose()`**                   | Оповещение о том, что пользователь проиграл.
**`void standoff()`**               | Оповещение о том, что прооизошла ничья.

#### Реализации интерфейса User
* **RealUser** - реализует взаимодействие с реальным пользователем. \
  `User userX = new RealUser(platform);` \
  Через переданную реализацию платформы взаимодействует с пользователем.
* **BotUser** - *абстрактный* класс-родитель для всех реализаций ботов. Содержит общие методы:

Название метода                  | Описание
---------------------------------|-----------------------------------------------------------------------------------------
**`List<Integer> getFreeIndexes(int[] board)`** | Получает все свободные индекты из текущего состояние доски (**board**)
**`int[] getBinaryBoard(SIGN[] board)`** | Преобразовывет исходную доску (массив SING) в массив Int [X: 1; O: -1; _: 0]

* **RandomUser** - Бот рандомайзер. Выбирает индекс ячейки рандомно из всех свободных
  `User userX = new RandomUser();`
* **AlgorithmBotUser** - средний по сложности бот. Прогнозирование на 1 глубину. Смотрит, сможет ли каким-либо ходом завершить игру победой текущим ходом. Если победа невозможна, то смотрит нужно ли защититься от опасной ситуации. Если нет - то выбирает рандомно.
  `User userX = new AlgorithmBotUser(SIGN.X);` \
  Аргумент *SIGN* в конструкторе указывает на знак бота (крестик или нолик)
* **MinMaxAlgorithmBotUser** - Бот работающий на алгоритме [minimax](https://www.baeldung.com/java-minimax-algorithm). Изучение данного алгоритма выходит за рамки данной документации. В сети вы найдете полно объяснений алгоритма. [раз](https://www.baeldung.com/java-minimax-algorithm), [два](http://ptsj.ru/articles/482/482.pdf), [три](https://tproger.ru/translations/tic-tac-toe-minimax/)
  `User userX = new MinMaxAlgorithmBotUser(SIGN.X);`
* **AIBotUser** - Бот на основе нейронной сети. Конструктор принимает 3 аргумента. Расположение файла сохраненной модели, знак бота (крестик или нолик) и флаг тренировать или нет нейронную сеть. \
  `User userX = new AIBotUser("/home/user/model", SIGN.X, true);` \
  После каждого цикла обучения нейронная сеть будет сохраняться в файле с путем переданным в конструктор **+"X"**/**+"O"**. Тоесть, если перать файл "model" и SIGN.X в качестве знака, то файл будет называться "modelX". Это обусловленно тем, что для разных знаков (X|O) используются разные модели.\
  Создание модели в конструкторе делегируется классу **AI**, который описан ниже. \
  `this.model = AI.createMultiLayerNetwork(modelFile);` \
  Обучение происходит в методах:
    * **`void win()`**
    * **`void lose()`**
    * **`void standoff()`**
##### При бинарной классификации (2 выходных значения) результатом нейронной сети будет:
  1. [0, 1] - Первый класс (в нашем случае победа)
  2. [1, 0] - Второй класс (в нашем случае поражение)

Обучающая выборка состоит из:
* Состояние доски
* Класс - победное или проигрышное состояние доски  

Например, если нейронная сеть играет за X и победил: 
```
X|O|X
O|X|O
X| | 
```
Обучаем нейронную сеть следущими данными: \
**[1, -1, 1, -1, 1, -1, 1, 0, 0]** - состояние доски \
**[0, 1]** - класс "Победа" 

##### Реализация AIBotUser
> класс


Название метода                  | Описание
---------------------------------|-----------------------------------------------------------------------------------------
**`int makeTurn(SIGN[] board)`**  | Преобразовывает доску в цифровой формат: `int[] binaryBoard = getBinaryBoard(board);`. Добавляет текущее состояние доски в память для дальнейшей обработки: `turns.add(binaryBoard);`. Возвращает индекс ячейки: `return tryTurn(binaryBoard, side, model);`                                
**`int tryTurn(int[] board, SIGN sign, MultiLayerNetwork model)`** | Получает свободные индексы: `List<Integer> indexes = getFreeIndexes(board);`. Получает максимальный лучший результат из нейронной сети `Integer resultIndex = indexes.stream()...`.
**`void win()`** | Обучает *позитивным* подкреплением если флаг обучение (**teaching**) переданный в конструктор `==true`. Получает список состояний доски из памяти (**`List<int[]> turns`**) с нужным нам положительными подкреплением: `List<DataSet> dataSets = getDataSets(new int[]{0, 1});` (с классом победа).
**`void lose()`** | Обучает *отрицательным* подкреплением если флаг обучение (**teaching**) переданный в конструктор `==true`. Получает список состояний доски из памяти (**`List<int[]> turns`**) с нужным нам положительными подкреплением: `List<DataSet> dataSets = getDataSets(new int[]{1, 0});` (с классом поражение).
**`void standoff()`**| Обучает *позитивным* подкреплением если флаг обучение (**teaching**) переданный в конструктор `==true`. Получает список состояний доски из памяти (**`List<int[]> turns`**) с нужным нам положительными подкреплением: `List<DataSet> dataSets = getDataSets(new int[]{0, 1});` (с классом победа). 
**`List<DataSet> getDataSets(int[] intLabels)`** | Получает список состояний доски в течении игры с переданным классом (победа/поражение) в качестве сравниваемого значения.

**Нейронная сеть тренируется на всех состояниях доски в течении игры. Причем чем дальше ход, тем больше колличеств итераций обучения.**
```
List<DataSet> dataSets = getDataSets(new int[]{1, 0});
for (int i = 0; i < EPOCH_NUM; i++) {
  for (int j = 0; j < dataSets.size(); j++) {
    for (int z = 0; z <= j; z++) {
      model.fit(dataSets.get(j));
    }
 }
}
```
* **EPOCH_NUM** в данном случае = 1 
* **dataSets** - обычающая выборка состоящая из состояний и класса 
* **`for (int z = 0; z <= j; z++)`** - чем дальше ход, тем больше итераций обучения 

#### AI
> класс

Класс с конфигурацией нейронной сети. \
Используется Framework для работы с нейронными сетями на Java - [Deeplearning4j](https://deeplearning4j.org/).\
Deeplearning4j [состоит](https://deeplearning4j.konduit.ai/config/maven) из 2х компонентов:
* [ND4J Backend](https://deeplearning4j.konduit.ai/config/backends) - бэкенд библиотеки линейной алгебры. Запускается в одтельном процессе. Есть 2 реализации бэкенда:
  * cuda - версия для GPU обработки. Можно использовать если установлен CUDA версии V9.2 и выше, а так же оборудование совместимо с NVIDIA.
    ```
      <dependency>
        <groupId>org.nd4j</groupId>
        <artifactId>nd4j-cuda-10.2</artifactId>
        <version>1.0.0-beta7</version>
      </dependency>
    ```
  * native - версия для CPU обработки.
     ```
      <dependency>
        <groupId>org.nd4j</groupId>
        <artifactId>nd4j-native</artifactId>
        <version>1.0.0-beta7</version>
      </dependency> 
      ```
* Core - реализации нейронной сети
```
  <dependency>
      <groupId>org.deeplearning4j</groupId>
      <artifactId>deeplearning4j-core</artifactId>
      <version>1.0.0-beta7</version>
  </dependency>
```

Название метода                  | Описание
---------------------------------|-----------------------------------------------------------------------------------------
**`static MultiLayerNetwork createMultiLayerNetwork(File modelFile)`** | создать или загрузить модеель

Архитектура нейронной сети: 
* [Метод оптимизации - Adam](https://habr.com/ru/post/318970/)
* Инициализация весов - XAVIER
* Колличество склытых слоев: 1
* Колличество нейронов в скрытом слое: 1000
* [Метод активации в скрытом слое - RELU](https://neurohive.io/ru/osnovy-data-science/activation-functions/)
* Колличество нейронов в выходном слое: 2
* Метод активации в выходном слое - SOFTMAX
* Функция потерь в выходном слое: NEGATIVELOGLIKELIHOOD


#### Board
> интерфейс

Название метода                  | Описание
---------------------------------|-----------------------------------------------------------------------------------------
**`void init()`**                 | Инициализация доски.
**`SIGN[] getState()`**           | Получить текущее состояние доски игры.
**`SIGN getState(int index)`**    | Получить знак из доски по индеку.
**`void setState(int index, SIGN t)`**| Установить на доску знак **t** в ячейку с индексом **index**.
**`SIGN getWinner()`**            | Получить победителя. Если игра не окончена, то будет возвращен `null`.
**`boolean isFinish()`**          | Получить флаг о завершении игры

Единственная реализация интерфейса **`Board`** - это **`BoardImpl`**.
`Board board = new BoardImpl();` 

#### Game
> класс

Класс с механикой игры.
Название метода                  | Описание
---------------------------------|-----------------------------------------------------------------------------------------
**` Game(Platform platform, Board board, User userX, User userO) `** | Конструктор. Принимает реализацию интерфейса **`Platform`**, реализацию интерфейса **`Board`**, и реализации интерфейса **`User`**.
**`void runGame()`** | Метод запускает игру. Инициализирует доску: `board.init();`, отрисовывает доску: `platform.draw(board.getState());` и запускает процесс приема ходов от **`User`**.
**`void showResult()`** | Показать результат игры. Делегирует реализации **`Platform`**. `platform.showResult(xWin, oWin, standoff);`


#### Main
> класс

Точка входа в программу.\
Задает:
* реализацию платформы: `Platform platform = new UIPlatform();`
* реализации пользователей: `User userX = new AIBotUser("/home/user/model", SIGN.X, true); new RealUser(platform);`
* реализацию доски: `Board board = new BoardImpl();`
* создает **Game**: `Game game = new Game(platform, board, userX, userO);`
И запусает игру в цикле: `game.runGame();`

### Статистика:
Ниже представлены результаты 1000 игр. \
В каждом случае за **X** играет **`RandomUser`**.
Алгоритм **O** бота              | Результат
---------------------------------|-----------------------------------------------------------------------------------------
**RandomUser**  | ![](https://github.com/jsamkt/configurations/blob/main/images/RandomVsRandom.png?raw=true) Видим, что по статистике у **X** в 2 раза больше шанса переиграть **O**.
**AlgorithmBotUser** | ![](https://github.com/jsamkt/configurations/blob/main/images/RandomVsAlgorithm.png?raw=true) Бот среднего уровня побеждает 10 к 1.
**MinMaxAlgorithmBotUser** | ![](https://github.com/jsamkt/configurations/blob/main/images/RandomVsMinMaxAlgorithm.png?raw=true) Алгоритм **MINIMAX** невозможно победить.
**AIBotUser** | ![](https://github.com/jsamkt/configurations/blob/main/images/RandomVsAI.png?raw=true) Как видно нейронная сеть обучилась и выигрывает 7 к 1, при том, что, как выяснилось, у **O** в 2 раза меньше шанса на победу. Но любой из алгоритмов (кроме Random) побеждает нейронную сеть.



